

<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      Dottie.js - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li >
        <a href="index.html">
          
            <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      dottie by Classroom Tech Tools.
    </h3>

    

    <h3>Classes</h3><ul><li id="Dottie-nav"><a href="Dottie.html">Dottie</a><ul class='methods'><li data-type="method" id="Dottie-copy-nav"><a href="Dottie.html#.copy">copy</a></li><li data-type="method" id="Dottie-delete-nav"><a href="Dottie.html#.delete">delete</a></li><li data-type="method" id="Dottie-dot-nav"><a href="Dottie.html#.dot">dot</a></li><li data-type="method" id="Dottie-expand-nav"><a href="Dottie.html#.expand">expand</a></li><li data-type="method" id="Dottie-get-nav"><a href="Dottie.html#.get">get</a></li><li data-type="method" id="Dottie-jsonsToRows-nav"><a href="Dottie.html#.jsonsToRows">jsonsToRows</a></li><li data-type="method" id="Dottie-move-nav"><a href="Dottie.html#.move">move</a></li><li data-type="method" id="Dottie-remove-nav"><a href="Dottie.html#.remove">remove</a></li><li data-type="method" id="Dottie-rowsToJsons-nav"><a href="Dottie.html#.rowsToJsons">rowsToJsons</a></li><li data-type="method" id="Dottie-set-nav"><a href="Dottie.html#.set">set</a></li><li data-type="method" id="Dottie-transfer-nav"><a href="Dottie.html#.transfer">transfer</a></li><li data-type="method" id="Dottie-transform-nav"><a href="Dottie.html#.transform">transform</a></li></ul></li></ul>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        Dottie.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>import DotObject from 'dot-object';

function Interface_ (name='', params={}) {
  class I_ {
    constructor (n, p) {
      this.name = `dottie.${n}`;
      this.params = p;
    }

    get req() {
      throw Error(`Missing at least one required parameter for ${this.name}: ${Object.keys(this.params)}`);
    }

    extra(kwargs) {
      if (Object.entries(kwargs).length > 0)
        throw Error(`Extra parameters passed to ${this.name}: ${Object.entries(kwargs)}`);
    }

    typecheck(args) {
      // arguments is an object-like array, need to flatten it so that we represent it as viewed from function scope
      let argObj = {};
      for (const prop in args) {
        argObj = {...argObj, ...args[prop]};
      }

      // now that both have matching types, let's go
      for (const prop in this.params) {
        if (this.params[prop] === 'any') continue;  // type of 'any' special meaning is to skip it
        if (argObj[prop] === undefined) continue;
        if (this.params[prop] === 'array') {
          if (!Array.isArray(argObj[prop])) throw new Error(`Type mismatch in ${this.name}: "${prop}". Expected array but got ${typeof(argObj)} instead`);
        } else if (typeof(argObj[prop]) !== this.params[prop]) {
          throw new Error(`Type mismatch in ${this.name}: "${prop}". Expected ${this.params[prop]} but got ${typeof(argObj[prop])} instead`);
        }
      }
    }
  }
  return new I_(name, params);
}


// create interfaces that allows us to enforce type checks
const MoveI = Interface_('move', {sourcePath: 'string', destPath: 'string', obj: 'object'});
const CopyI = Interface_('copy', {obj: 'object', sourcePath: 'string', target: 'object', destPath: 'string'});
const TransferI = Interface_('transfer', {sourcePath: 'string', destPath: 'string', obj: 'object', target: 'object'});
const ExpandI = Interface_('expand', {obj: 'object'});
const GetI = Interface_('get', {path: 'string', obj: 'object'});
const SetI = Interface_('set', {path: 'string', obj: 'object', value: 'any'});
const DeleteI = Interface_('delete', {path: 'string', obj: 'object'});
const RemoveI = Interface_('remove', {path: 'string', obj: 'object'});
const TransformI = Interface_('transform', {recipe: 'object', obj: 'object'});
const DotI = Interface_('dot', {obj: 'object'});
const JsonsI = Interface_('jsons', {jsons: 'array', priorityHeaders: 'array', deleteNulls: 'boolean', deleteEmptyArrays: 'boolean'});
const RowsI = Interface_('rows', {rows: 'array'});

/**
 * Internal class object. Global methods interface with these methods. If `augment` is used, these methods are augmented to Objects and Arrays with these function signatures.
 * @class
 */
class Dottie {

  /**
   * No instances are made, all these methods are static
   */
  constructor () {

  }

  /**
   * @see {@link move}
   * @param {Object} namedParameters
   * @param {String} namedParameters.sourcePath
   * @param {String} namedParameters.destPath
   * @param {Object} namedParameters.obj
   * @return {Object}
   */
  static move ({sourcePath=MoveI.req, destPath=MoveI.req, obj=MoveI.req, ...kwargs}={}) {
    MoveI.extra(kwargs);
    MoveI.typecheck(arguments);
    return DotObject.move(sourcePath, destPath, obj);
  }

  /**
   * @see {@link copy}
   * @param {Object} namedParameters
   * @param {Object} namedParameters.obj
   * @param {String} namedParameters.sourcePath
   * @param {String} namedParameters.target
   * @param {String} namedParameters.destPath
   * @return {Object}
   */
  static copy ({obj=CopyI.req, sourcePath=CopyI.req, target=CopyI.req, destPath=CopyI.req, ...kwargs}={}) {
    CopyI.extra(kwargs);
    CopyI.typecheck(arguments);
    return DotObject.copy(sourcePath, destPath, obj, target);
  }

  /**
   * @see {@link transfer}
   * @param {Object} namedParameters
   * @param {String} namedParameters.sourcePath
   * @param {String} namedParameters.destPath
   * @param {Object} namedParameters.obj
   * @param {Object} namedParameters.target
   * @return {Object}
   */
  static transfer ({sourcePath=TransferI.req, destPath=TransferI.req, obj=TransferI.req, target=TransferI.req, ...kwargs}={}) {
    TransferI.extra(kwargs);
    TransferI.typecheck(arguments);
    return DotObject.transfer(sourcePath, destPath, obj, target);
  }

  /**
   * @see {@link expand}
   * @param {Object} namedParameters
   * @param {Object} namedParameters.obj
   * @returns {Object}
   */
  static expand ({obj=ExpandI.req, ...kwargs}={}) {
    ExpandI.extra(kwargs);
    ExpandI.typecheck(arguments);
    return DotObject.object(obj);
  }

  /**
   * @see {@link get}
   * @param {Object} namedParameters
   * @param {String} namedParameters.path
   * @param {Object} namedParameters.obj
   * @returns {Any}
   */
  static get ({path=GetI.req, obj=GetI.req, ...kwargs}={}) {
    GetI.extra(kwargs);
    GetI.typecheck(arguments);
    const result = DotObject.pick(path, obj);
    if (result === undefined) return null;
    return result;
  }

  /**
   * @see {@link set}
   * @param {Object} namedParameters
   * @param {String} namedParameters.path
   * @param {Any} namedParameters.value
   * @param {Object} namedParameters.obj
   * @returns {Object}
   */
  static set ({path=SetI.req, value=SetI.req, obj=SetI.req, ...kwargs}={}) {
    SetI.extra(kwargs);
    SetI.typecheck(arguments);
    return DotObject.str(path, value, obj);
  }

  /**
   * @see {@link delete_}
   * @param {Object} namedParameters
   * @param {String} namedParameters.path
   * @param {Object} namedParameters.obj
   * @returns {Object}
   */
  static delete ({path=DeleteI.req, obj=DeleteI.req, ...kwargs}={}) {
    DeleteI.extra(kwargs);
    DeleteI.typecheck(arguments);
    return DotObject.delete(path, obj);
  }

  /**
   * @see {@link remove}
   * @param {Object} namedParameters
   * @param {String} namedParameters.path
   * @param {Object} namedParameters.obj
   * @returns {Object}
   */
  static remove ({path=RemoveI.req, obj=RemoveI.req, ...kwargs}={}) {
    RemoveI.extra(kwargs);
    RemoveI.typecheck(arguments);
    return DotObject.remove(path, obj);
  }

  /**
   * @see {@link set}
   * @param {Object} namedParameters
   * @param {String} namedParameters.path
   * @param {Any} namedParameters.value
   * @param {Object} namedParameters.obj
   * @returns {Object}
   */
  static transform ({recipe=TransformI.req, obj=TransformI.req, ...kwargs}={}) {
    TransformI.extra(kwargs);
    TransformI.typecheck(arguments);
    return DotObject.transform(recipe, obj);
  }

  /**
   * @see {@link dot}
   * @param {Object} namedParameters
   * @param {Object} namedParameters.obj
   * @returns {Object}
   */
  static dot ({obj=DotI.req, ...kwargs}={}) {
    DotI.extra(kwargs);
    DotI.typecheck(arguments);
    return DotObject.dot(obj);
  }

  /**
   * @see {@link jsonsToRows}
   * @param {Object} namedParameters
   * @param {Object[]} namedParameters.jsons
   * @param {String[]} [namedParameters.priorityHeaders=[]]
   * @param {Boolean} [namedParameters.deleteNulls=false]
   * @param {Boolean} [namedParameters.deleteEmptyArrays=true]
   * @returns {Array[]}
   */
  static jsonsToRows ({jsons=JsonsI.req, priorityHeaders=[], deleteNulls=false, deleteEmptyArrays=true, ...kwargs}={}) {
    JsonsI.extra(kwargs);
    JsonsI.typecheck(arguments);
    const headers = [];
    const values = [];

    // save values as dotted objects and store headers
    // remove any nulls
    for (const json of jsons) {
      const value = DotObject.dot(json);
      for (const [k, v] of Object.entries(value)) {
        if ( (deleteNulls &amp;&amp; v === null) || (deleteEmptyArrays &amp;&amp; Array.isArray(v) &amp;&amp; v.length===0) ) {
          delete value[k];
        }
      }
      headers.push(Object.keys(value));
      values.push(value);
    }

    // row1 will consist of unique header columns, sorted alphabetically with id first
    // use array generics for most efficient manner of doing this
    const row1 = [...new Set([].concat(...headers))];
    row1.sort();
    for (const [i, h] of priorityHeaders.entries()) {
      const idx = row1.indexOf(h);
      if (idx !== -1) {
        row1.splice(idx, 1);      // remove
        row1.splice(i, 0, h);  // insert at front
      }

    }

    // the rest of the rows consits of the values in each column, or null if not present
    const rows = values.map(value => row1.map(column => value[column] === false ? false : value[column] || null));

    // concat the arrays efficiently for return
    return [row1, ...rows];
  }

  /**
   * @see {@link rowsToJsons}
   * @param {Object} namedParameters
   * @param {Any[][]} namedParameters.rows
   * @returns {Any[]}
   */
  static rowsToJsons ({rows=RowsI.req, ...kwargs}={}) {
    RowsI.extra(kwargs);
    RowsI.typecheck(arguments);
    const headers = rows[0];
    const objects = [];

    // go through row 1 to end
    for (const row of rows.slice(1)) {
      const dotted = row.reduce(
        function (acc, value, idx) {
          // safeguard if for some reason empty string for column or null
          const column = headers[idx] || null;
          if (!column) return acc;

          // set and return
          acc[column] = value;
          return acc;
        }, {}
      );
      const obj = DotObject.object(dotted);
      objects.push(obj);
    }
    return objects;
  }

  /*
    Sets up {}.dottie and [].dottie methods
    @param {Any} O - Pass your `Object`
    @param {Any} A - Pass your `Array`
   */
  static augment (O=null, A=null) {
    if (O === null) O = Object;
    if (A === null) A = Array;
    const me = this;
    !A.prototype.dottie &amp;&amp; Object.defineProperty(A.prototype, 'dottie', {
      get: function () {
        return {
          jsonsToRows: ({priorityHeaders=[], ...kwargs}={}) => {
            return me.jsonsToRows({jsons:this, priorityHeaders});
          },
          rowsToJsons: ({...kwargs}={}) => {
            return me.rowsToJsons({rows: this});
          }
        };
      }
    });

    !O.prototype.dottie &amp;&amp; Object.defineProperty(O.prototype, 'dottie', {
      get: function () {
        return {
          set: ({path, value}={}) => {
            return DotObject.str(path, value, this);
          },
          get: ({path}={}) => {
            return DotObject.pick(path, this);
          },
          move: ({path, destPath}={}) => {
            return DotObject.move(path, destPath, this);
          },
          copy: ({path, destPath, target}={}) => {
            return DotObject.copy(path, destPath, this, target);
          },
          transfer: ({path, destPath, target}={}) => {
            return DotObject.transfer(path, destPath, this, target);
          },
          expand: () => {
            return DotObject.object(this);
          },
          delete: ({path}={}) => {
            return DotObject.delete(path, this);
          },
          remove: ({path}) => {
            return DotObject.remove(path, this);
          },
          transform: ({recipe}={}) => {
            return DotObject.transform(recipe, this);
          },
          dot: ({target, path}={}) => {
            return DotObject.dot(this, target, path);
          }
        };
      }
    });
  }

}

export {Dottie};
</code></pre>
  </article>
</section>

    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  

</body>
</html>
